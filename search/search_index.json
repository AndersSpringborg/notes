{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Anders Aaen Springborg - Noter Siden indeholder lige nu noter fra: 3 Semester 4 Semester 5 Semester test","title":"Home"},{"location":"#anders-aaen-springborg-noter","text":"Siden indeholder lige nu noter fra: 3 Semester 4 Semester 5 Semester test","title":"Anders Aaen Springborg - Noter"},{"location":"4-semester/","text":"Indhold Kurser: PSS - Principles of Operating Systems and Concurrency Moodle side: https://www.moodle.aau.dk/course/view.php?id=28797","title":"Index"},{"location":"4-semester/#indhold","text":"Kurser: PSS - Principles of Operating Systems and Concurrency Moodle side: https://www.moodle.aau.dk/course/view.php?id=28797","title":"Indhold"},{"location":"4-semester/PSS/exam/","text":"PSS d. 4/6 Form Topic - 28/5 - Processes and Threads - Definition of process/thread (why do we need processes?) - Process \u2192 A running program. - Limited access to cpu and I/O - Er i forskellige stadier machine state - memory \u2192 skrive / l\u00e6se - registre \u2192 l\u00e6se og opdatere registre - I/O \u2192 tilg\u00e5r andre enheder | harddisk, mus, tastatur, usb - An illusion (virtualization) of a CPU - Thred \u2192 - process-/threadcontrol block (how are processes/threads implemented in the OS?) - Process technique = **time sharing** - low-level machinery = **mechanisms** - Low level protocols / functions - `API` - `CREATE` - `DESTROY` - `WAIT` til en process er f\u00e6rdig med at k\u00f8re - `Miscellaneous Control`: kunne fx v\u00e6re at suspendere et process it et stykke tid, for at den skal k\u00f8re videre bagefter - `Status`: hvor lang tid har en process k\u00f8rt, hvilket stadie er den i? - 5-state process model (what is the lifecycle of a process?) - New: processen er ikke blevet indl\u00e6st i hukommelsen endnu - Ready: processen er klar til k\u00f8re instruktioner - Running: K\u00f8rer intruktioner - Blocked: venter p\u00e5 et event (evt i/o eller netv\u00e6rks pakke) - Exit: frigivet fra hukommelsen - process creation 1. Indl\u00e6s kode og statiske date (initialiserede variable) fra harddisk ind i hukommelsen - moderne os bruger lazy loading og indl\u00e6ser kun n\u00f8dvendige sider (memory pages) 2. Allokere plads til stakken - intialisere `argc` og `argv` med input fra terminalen 3. Allokere plads til heapen 4. Forbinder I/O til processen - fx hvor printf skal skrive til 5. K\u00f8r entrypoint i programmet (fx k\u00f8r main i C) - process/thread switching - **process list** relevant info om alle k\u00f8rende processor &darr; `XV6` De er meget komplexe i rigtige OS. - **register context**: indholdet p\u00e5 en proces - - **scheduling policy** hvilket program skal k\u00f8rer f\u00f8rst - en **context switch** som stopper et program, for at k\u00f8re et andet | **mechanism** - multi-threading - implementation strategies for thread support - user-/kernel-/hybrid-mode (what are the pros and cons of of the different approaches?) 29/5 Scheduling Definition of scheduler (what is a scheduler? why do we need a scheduler?) Metrics for scheduling: fairness, turnaround time, response time (what is a good scheduler?) simple process model scheduling policies (FIFO, SJF, STCF, Round Robin, MLFQ, lottery scheduler) 30/5 Memory management Memory hierarchy (why don\u2019t we just use registers for everything?) goals for memory management (transparency, efficiency, isolation) Transperant (interface for programm\u00f8re) En abstraction, s\u00e5 man ved der sker, men ikke hvordan det sker Opn\u00e5es ved at man ikke skal t\u00e6nke p\u00e5 fysiske adresser Effektivt Hukommelsen bliver brugt hele tiden, s\u00e5 det skal v\u00e6re hurtigt, da det har stor indflydelse p\u00e5 systemes oplevelse. (alt ville v\u00e6re langsomt) Opn\u00e5es med MMU Beskyttelse S\u00e5 process a ikke l\u00e6ser eller skriver til process b. Hvis der l\u00e5 et password eller api n\u00f8gle i process b. S\u00e5 ingen process g\u00f8r \u00e6ndre noget ved OS. \"jeg skal k\u00f8re i kernal mode\" Det opn\u00e5es ved isolation Hvis der ikke var nogle h\u00e5ndtering, skulle vi skrive proces a til hardisken, for at derfter at l\u00e6se proces b. Det er ineffektivt address space (what is an address space? why do we need that abstraction?) hvordan hukommelsen er lagt ud for processen kan bruge virtual memory (what exactly is virtual memory?) En abstraction til at g\u00f8re humkommelsen p\u00e6n K\u00f8r det p\u00e6nt for programm\u00f8ren Kan bruge swap hukommelsen, s\u00e5 man udvider hukommelsen Forventninger: sammenh\u00e6ngende tildeling Sm\u00e5t adresse rum l\u00e5st st\u00f8rrelse p\u00e5 tildeling challenges for memory management Hvordan man bruger alt hukommelsen. Fx hvis der er free space mellem proc a og proc b S\u00e5 kan vi have 2 programmer i hukommelsen features (relocation, protection, and sharing) virtual addresses vs. physical addresses (why do we need virtual addresses? how can we translate a virtual address to a physical address?) virtuelle ease of use til programm\u00f8re det er en abstraction/API p\u00e5 hukommelses adresses Sikkerhed, vi skal undg\u00e5 at et program ikke kigger p\u00e5 andre programmer address translation va + BASE register = fysisk adresse er fysisk adresse mindre end BOUND og st\u00f8rre end BASE? ok ,ellers error/kill Det sker p\u00e5 MMU (memory manage unit) effektivt fordi det sker p\u00e5 hardware niveau segmentation (what problem does it solve? how is it implemented? what are the problems with segmentation?) Der kan v\u00e6re spild plads, i den allokeret blok. (fx der er meget plads mellem heapen og stakken) tre segmenter: kode segment heap segment stak segment l\u00f8ses med base bound til hver segment (3 par her) fys adresse = OFFSET(virtual base) + BASE fys adresse =va + vbase + BASE trick: code = 00 heap = 01 stak = 11 base and bound registers (what are they? how do they work? why do they work?) base | va 0 = fysisk start adresse bound | va max = fysisk slut adresse Sikre at vi ikke skriver til noget udenfor vores stykke hukommelse simple allocation dynamic allocation 31/5 Paged memory Address types (physical, relative, virtual) Pages and frames (what are they? where do they reside? how big are they typically?) address translation page tables (what are they? how many are there? what are they used for? how are they used?) virtual memory, swapping, shared memory (why is that easy with paged memory?) page replacement algorithms (OPT, LRU, FIFO, CLOCK) 1/6 Concurrency Multi-threading (what is that? why would we want that?) implementation strategies for multi-threading (how is it implemented? what are the tradeoffs os the different implementation approaches?) concurrency vs. parallelism (what is the difference? why is it important?) inter-process communication race conditions (what are they? is it a problem?) mutual exclusion (why would we want that?) ensuring mutual exclusion (algorithms, hardware supported, mutexes, semaphores, monitors) 2/6 Concurrency problems Definition of deadlock (what is it? is it a real problem?) Mutual exclusion (what is it? why do we want that?) Resource allocation graph (what is it? how to make one? why can we use it for?) Coffman\u2019s conditions Solution strategies (prevention, avoidance, detection and recovery) How to achieve deadlock prevention (breaking Coffman\u2019s conditions) Safe states and deadlock avoidance Deadlock detection and recovery, livelock, priority inversion. 3/6 XV6 Process switching XV6 components involved in process swithcing (what files are involved? what functions are involved? what parts of the OS are involved?) challenges (how is user-space/kernel-space switch handled? how/when is a process de-scheduled?) SPO 08/6 Link to moodle Language Design Sequence control and Subprogram Control Language Design Criteria Evaluation of expressions Explicit sequence control vs. structured sequence control Loop constructs Subprogram Parameter mechanisms Structure of the compiler Describe the phases of the compiler and give an overall description of what the purpose of each phase is and how the phases interface Single pass vs. multi pass compiler Issues in language design Issues in code generation Lexical analysis Describe the role of the lexical analysis phase Describe how a scanner can be implemented by hand or auto-generated Describe regular expressions and finite automata Parsing Describe the purpose of the parser Discuss top down vs. bottom up parsing Explain necessary conditions for construction of recursive decent parsers Discuss the construction of an RD parser from a grammar Discuss bottom Up/LR parsing Semantic Analysis Describe the purpose of the Semantic analysis phase Discuss Identification and type checking Discuss scopes/block structure and implication for implementation of identification tables/symbol tables Discuss Implementation of semantic analysis Run-time organization Data representation (direct vs. indirect) Storage allocation strategies: static vs. stack dynamic Activation records (sometimes called frames) Routines and Parameter passing Heap allocation and Garbage Collection Why may we need heap allocation? Garbage collection strategies (Types of GCs) Code Generation Describe the purpose of the code generator Discuss Intermediate representations Describe issues in code generation Code templates and implementations Back patching Implementation of functions/procedures/methods Register Allocation and Code Scheduling SS 12/6 Link to moodle Generelt - 5 Opgaver - 2 sider pr opgave -> 10 sider i alt -","title":"Exam"},{"location":"4-semester/PSS/exam/#pss-d-46","text":"Form Topic - 28/5 - Processes and Threads - Definition of process/thread (why do we need processes?) - Process \u2192 A running program. - Limited access to cpu and I/O - Er i forskellige stadier machine state - memory \u2192 skrive / l\u00e6se - registre \u2192 l\u00e6se og opdatere registre - I/O \u2192 tilg\u00e5r andre enheder | harddisk, mus, tastatur, usb - An illusion (virtualization) of a CPU - Thred \u2192 - process-/threadcontrol block (how are processes/threads implemented in the OS?) - Process technique = **time sharing** - low-level machinery = **mechanisms** - Low level protocols / functions - `API` - `CREATE` - `DESTROY` - `WAIT` til en process er f\u00e6rdig med at k\u00f8re - `Miscellaneous Control`: kunne fx v\u00e6re at suspendere et process it et stykke tid, for at den skal k\u00f8re videre bagefter - `Status`: hvor lang tid har en process k\u00f8rt, hvilket stadie er den i? - 5-state process model (what is the lifecycle of a process?) - New: processen er ikke blevet indl\u00e6st i hukommelsen endnu - Ready: processen er klar til k\u00f8re instruktioner - Running: K\u00f8rer intruktioner - Blocked: venter p\u00e5 et event (evt i/o eller netv\u00e6rks pakke) - Exit: frigivet fra hukommelsen - process creation 1. Indl\u00e6s kode og statiske date (initialiserede variable) fra harddisk ind i hukommelsen - moderne os bruger lazy loading og indl\u00e6ser kun n\u00f8dvendige sider (memory pages) 2. Allokere plads til stakken - intialisere `argc` og `argv` med input fra terminalen 3. Allokere plads til heapen 4. Forbinder I/O til processen - fx hvor printf skal skrive til 5. K\u00f8r entrypoint i programmet (fx k\u00f8r main i C) - process/thread switching - **process list** relevant info om alle k\u00f8rende processor &darr; `XV6` De er meget komplexe i rigtige OS. - **register context**: indholdet p\u00e5 en proces - - **scheduling policy** hvilket program skal k\u00f8rer f\u00f8rst - en **context switch** som stopper et program, for at k\u00f8re et andet | **mechanism** - multi-threading - implementation strategies for thread support - user-/kernel-/hybrid-mode (what are the pros and cons of of the different approaches?) 29/5 Scheduling Definition of scheduler (what is a scheduler? why do we need a scheduler?) Metrics for scheduling: fairness, turnaround time, response time (what is a good scheduler?) simple process model scheduling policies (FIFO, SJF, STCF, Round Robin, MLFQ, lottery scheduler) 30/5 Memory management Memory hierarchy (why don\u2019t we just use registers for everything?) goals for memory management (transparency, efficiency, isolation) Transperant (interface for programm\u00f8re) En abstraction, s\u00e5 man ved der sker, men ikke hvordan det sker Opn\u00e5es ved at man ikke skal t\u00e6nke p\u00e5 fysiske adresser Effektivt Hukommelsen bliver brugt hele tiden, s\u00e5 det skal v\u00e6re hurtigt, da det har stor indflydelse p\u00e5 systemes oplevelse. (alt ville v\u00e6re langsomt) Opn\u00e5es med MMU Beskyttelse S\u00e5 process a ikke l\u00e6ser eller skriver til process b. Hvis der l\u00e5 et password eller api n\u00f8gle i process b. S\u00e5 ingen process g\u00f8r \u00e6ndre noget ved OS. \"jeg skal k\u00f8re i kernal mode\" Det opn\u00e5es ved isolation Hvis der ikke var nogle h\u00e5ndtering, skulle vi skrive proces a til hardisken, for at derfter at l\u00e6se proces b. Det er ineffektivt address space (what is an address space? why do we need that abstraction?) hvordan hukommelsen er lagt ud for processen kan bruge virtual memory (what exactly is virtual memory?) En abstraction til at g\u00f8re humkommelsen p\u00e6n K\u00f8r det p\u00e6nt for programm\u00f8ren Kan bruge swap hukommelsen, s\u00e5 man udvider hukommelsen Forventninger: sammenh\u00e6ngende tildeling Sm\u00e5t adresse rum l\u00e5st st\u00f8rrelse p\u00e5 tildeling challenges for memory management Hvordan man bruger alt hukommelsen. Fx hvis der er free space mellem proc a og proc b S\u00e5 kan vi have 2 programmer i hukommelsen features (relocation, protection, and sharing) virtual addresses vs. physical addresses (why do we need virtual addresses? how can we translate a virtual address to a physical address?) virtuelle ease of use til programm\u00f8re det er en abstraction/API p\u00e5 hukommelses adresses Sikkerhed, vi skal undg\u00e5 at et program ikke kigger p\u00e5 andre programmer address translation va + BASE register = fysisk adresse er fysisk adresse mindre end BOUND og st\u00f8rre end BASE? ok ,ellers error/kill Det sker p\u00e5 MMU (memory manage unit) effektivt fordi det sker p\u00e5 hardware niveau segmentation (what problem does it solve? how is it implemented? what are the problems with segmentation?) Der kan v\u00e6re spild plads, i den allokeret blok. (fx der er meget plads mellem heapen og stakken) tre segmenter: kode segment heap segment stak segment l\u00f8ses med base bound til hver segment (3 par her) fys adresse = OFFSET(virtual base) + BASE fys adresse =va + vbase + BASE trick: code = 00 heap = 01 stak = 11 base and bound registers (what are they? how do they work? why do they work?) base | va 0 = fysisk start adresse bound | va max = fysisk slut adresse Sikre at vi ikke skriver til noget udenfor vores stykke hukommelse simple allocation dynamic allocation 31/5 Paged memory Address types (physical, relative, virtual) Pages and frames (what are they? where do they reside? how big are they typically?) address translation page tables (what are they? how many are there? what are they used for? how are they used?) virtual memory, swapping, shared memory (why is that easy with paged memory?) page replacement algorithms (OPT, LRU, FIFO, CLOCK) 1/6 Concurrency Multi-threading (what is that? why would we want that?) implementation strategies for multi-threading (how is it implemented? what are the tradeoffs os the different implementation approaches?) concurrency vs. parallelism (what is the difference? why is it important?) inter-process communication race conditions (what are they? is it a problem?) mutual exclusion (why would we want that?) ensuring mutual exclusion (algorithms, hardware supported, mutexes, semaphores, monitors) 2/6 Concurrency problems Definition of deadlock (what is it? is it a real problem?) Mutual exclusion (what is it? why do we want that?) Resource allocation graph (what is it? how to make one? why can we use it for?) Coffman\u2019s conditions Solution strategies (prevention, avoidance, detection and recovery) How to achieve deadlock prevention (breaking Coffman\u2019s conditions) Safe states and deadlock avoidance Deadlock detection and recovery, livelock, priority inversion. 3/6 XV6 Process switching XV6 components involved in process swithcing (what files are involved? what functions are involved? what parts of the OS are involved?) challenges (how is user-space/kernel-space switch handled? how/when is a process de-scheduled?)","title":"PSS d. 4/6"},{"location":"4-semester/PSS/exam/#spo-086","text":"Link to moodle Language Design Sequence control and Subprogram Control Language Design Criteria Evaluation of expressions Explicit sequence control vs. structured sequence control Loop constructs Subprogram Parameter mechanisms Structure of the compiler Describe the phases of the compiler and give an overall description of what the purpose of each phase is and how the phases interface Single pass vs. multi pass compiler Issues in language design Issues in code generation Lexical analysis Describe the role of the lexical analysis phase Describe how a scanner can be implemented by hand or auto-generated Describe regular expressions and finite automata Parsing Describe the purpose of the parser Discuss top down vs. bottom up parsing Explain necessary conditions for construction of recursive decent parsers Discuss the construction of an RD parser from a grammar Discuss bottom Up/LR parsing Semantic Analysis Describe the purpose of the Semantic analysis phase Discuss Identification and type checking Discuss scopes/block structure and implication for implementation of identification tables/symbol tables Discuss Implementation of semantic analysis Run-time organization Data representation (direct vs. indirect) Storage allocation strategies: static vs. stack dynamic Activation records (sometimes called frames) Routines and Parameter passing Heap allocation and Garbage Collection Why may we need heap allocation? Garbage collection strategies (Types of GCs) Code Generation Describe the purpose of the code generator Discuss Intermediate representations Describe issues in code generation Code templates and implementations Back patching Implementation of functions/procedures/methods Register Allocation and Code Scheduling","title":"SPO 08/6"},{"location":"4-semester/PSS/exam/#ss-126","text":"Link to moodle Generelt - 5 Opgaver - 2 sider pr opgave -> 10 sider i alt -","title":"SS 12/6"}]}